---
title: "ps-3-release-CianStryker"
author: "Cian Stryker"
date: "9/20/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

# First step is to load all the various packages I need in this document. Most
# make sense like "readxl", "gt" and dplyr/tidyverse because they're required
# for starting the project and working with data per the instructions in the
# problem set. I've added a few more though. "Janitor" is good to clean the data
# names originally. "Styler" formats everything so I don't have to. Also I use
# "cowplot" to put two ggplot graphs on one pane. I also use plyr to merge rows
# of data later on. One important note here, I have to load plyr before dplyr to
# use both effectivley.

library(readxl)
library(gt)
library(janitor)
library(plyr)
library(styler)
library(cowplot)
library(tidyverse)
```

```{r Loading}
enrollment <- read_excel("raw-data/class_enrollment_summary_by_term_9.16.19.xlsx", skip = 3) %>%
  clean_names() %>%
  head(-7)

# Here I'm just shifting the data to a readable format by R. Also the clean_names() function is useful to change all variable names to lowercase and also to use "_" instead of spaces. This makes everything easier and I should use this everytime I do a project.
```
## Madlibs
```{r Question 1}
l <- nrow(enrollment)

# Since I wanted to know every course that was listed, regardless of whether it was repeated, I went with just counting the rows for the entire dataset. No need to specify a variable one way or the other here.
```
The total number of classes is `r l`. 
```{r Question 2}
question_2 <- unique(enrollment$course_department) %>%
  na.omit(question_2)

# Here the key is in the question. Instead of wanting a list of every department, it specifies that it wants "distint" departments. So counting the rows would be incorrect and instead I only wanted the distinct entries.

y <- length(question_2)

# After clearing the column "course_department" of all repeated department entries, I was just able to count how many entries were left with the "length()" command.
```
The number of distinct departments is `r y`.
```{r Question 3}
question_3 <- enrollment %>%
  select(course_department, course_name) %>%
  count(course_department) %>%
  filter(n == 69)

# This question was a little more complicated, but the approach wasn't too different from question_1. First I had to grab just "course_department" and "course_name" and count only course_department. Then I was able to filter out all entries that didn't have exactly 69 course_names listed under it.

w <- question_3[1, 1]

# Just like question_1 I was able to then just count the number of rows in the new dataframe.
```
The department with 69 courses listed is `r w`.
```{r Question 4}
question_4 <- enrollment %>%
  select(course_title, total) %>%
  filter(total == 5) %>%
  count(course_title, total)

# This is essentially question_3 but instead of course_department, I was after total enrollment in individual classes. But the same process applied. Select my target variables and then filter out the desired "total" target. One note though, I had to count both "course_name" and "total", or else I didn't get the information I wanted. There is an additional column labeled "n" in this new dataframe, but it doesn't prevent me from getting the information I want.

v <- nrow(question_4)

# Same concept again here. I only need to count the rows to finish the question.
```
The number of classes with a total enrollment of exactly 5 is `r v`.
```{r Question 5}
question_5 <- enrollment %>%
  select(course_name, u_grad, grad) %>%
  filter(u_grad >= 1) %>%
  filter(grad > u_grad) %>%
  count(course_name, u_grad, grad)

# This was more complicated, but it started the same way as the others. Create a new dataframe and select the variables I needed: course_name, u_grad, and grad. Then it's just a matter of filtering the various specifications the question needed. Finally, like question_4, I had to count all three target variables to get the information I wanted.

u <- nrow(question_5)

# Once again a simple nrow() command was sufficient to provide a single numerical answer I could then write into my inline r code.
```
The number of classes with at least one undergrad enrolled and with a larger graduate student than undergraduate enrollment is `r u`.  
```{r Question 6}
part1 <- enrollment %>%
  select(u_grad, course_department) %>%
  filter(course_department == "Government") %>%
  summarise(medGS = median(u_grad))

# So I decided to handle this question by creating two dataframes with the target information I wanted and then to subtract them from eachother. First I found the median of undergraduates in a Government class. The only thing different from previous questions was the use of the summarise() function, which I used to create the new variable medGS, which is the only column visible in the new data set "part1".

part2 <- enrollment %>%
  select(u_grad, course_department) %>%
  filter(course_department == "Economics") %>%
  summarise(medES = median(u_grad))

# Here I just repeated my process from "part1" to make "part2". Not the most imaginative naming structure, but I give myself a pass. The important note is that now I have two dataframes that just have a column with the median of undergraduate Gov students and the median of undergraduate Econ students.

part3 <- data.frame(part1 = c(6), B = c(2))
a <- (part1 - part2)

# Here I had to find a way to subtract my two new dataframes from eachother. I found out the simplest way to do that was to use baseR. With the data.frame() command I could list my two dataframes and list them as just the numeric answers I wanted. Then I ccan create my final variable "a" as the differnce between them.
```
The median number of undergraduates enrolled in a Government is `r a` students greater than the median enrolled in an Economics class. 

```{r Setup for Table}
stage1 <- enrollment %>%
  select(course_title, course_name, course_department, u_grad) %>%
  filter(course_department == "Government")

# To start my table I wanted to create a dataframe with just the information seen in Dr. Kaine's table. So I made the first one with just the title, name, department, and number of undergraduates, with a filter for only Gov courses.

stage2 <- stage1 %>%
  filter(u_grad >= 38) %>%
  select(course_title, course_name, u_grad) %>%
  arrange(desc(u_grad))

# I noticed that the Gov courses were in a specific order so I guessed that a arrange(desc()) was used, but I had to filter out a bunch of classes. The lowest enrolled course had 38 students in it, so I filtered out all Gov classes with less students and then sorted them in descending order. This created a dataframe with my information displayed just like I saw in the problem set. I figured this would make actually creating the table easier.

names(stage2) <- c("Number", "Name", "Enrollment")

# Here I just wanted to shift the names of the columns to match the new table. I'm not sure if you can do this with the "gt" package or not, but I did it here instead.
```
## Table
```{r Table}
gt(stage2) %>%
  tab_header(
    title = "Highest Enrollment Government Classes",
    subtitle = "Fall 2019"
  ) %>%
  tab_footnote(
    footnote = "Based on Harvard Registrar data from September 16, 2019.",
    locations = cells_title(groups = c("title"))
  ) %>%
  tab_footnote(
    footnote = "Undergraduate enrollment only.",
    locations = cells_data(
      columns = vars(Enrollment),
      rows = 1
    )
  )

# Through a ton of googling and a fair amount of trial and error, I was able to create a table that matched the problem set. The gt() function creates the table, but devoid of the specifications I needed. Tab_header() gives me the title info I needed and seemed pretty self-explanatory, but tab_footnote() gave me more trouble. I understood the footnote = portion worked like labs(title = xx), but the location portion gave me some trouble. Eventually I found out how to specify where I wanted each footnote. This resulted in the completed table.
```

```{r Set Up for Classes Graphic}
trial <- enrollment %>%
  select(course_name, course_department, u_grad, grad, total) %>%
  arrange(desc(u_grad)) %>%
  na.omit(trial) %>%
  head(10)

# So I decided I wanted to look at the most popular classes for undergraduate and graduate students for the Fall. I tried to do some work with the facet_wrap() command but I couldn't figure out how to remove duplicated entries in my two graphs. Eventually I decided to just make two graphs and use another package to join them onto one page. The setup work is here for this first part though. Essentially, I grabbed the the highest 10 courses enrolled by undergraduates and saved it to a dataframe.

trial2 <- enrollment %>%
  select(course_name, course_department, u_grad, grad, total) %>%
  arrange(desc(grad)) %>%
  na.omit(trial2) %>%
  head(10)

# Here is the mirror of the first stage but for Graduate students. I don't think I needed to select out the variables course_department or u_grad, but I was using these chunks to view the information sometimes with more variables included. I would just copy/paste a section of the code to do that, so I've left them in here to show that.
```
## Graphics: Most Popular Classes 
```{r Graphic: Classes}
plot1 <- ggplot(trial, aes(x = reorder(course_name, -u_grad), y = u_grad, fill = course_name)) +
  labs(
    title = "Top 10 Undergraduate Courses",
    subtitle = "By Enrollment, Fall 2019",
    x = "Course Name",
    y = "Enrollment"
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8)) +
  geom_col() +
  guides(fill = FALSE)

# Here I wanted to create my first graph for the undergraduate classes. Nothing particularly complicated here, but I did use the reorder() function when specifying the x axis so that the classes would be in descending order. I also put the angle of my text at 60 so that they could be read and not bunched together horizontally. One note though, I could either use course_title or course_name for my x axis. Course_title fit better but people dont' really know the course code well enough for it to be that useful. Course_name is better, but some of the course names are cut off in the original data set, which I didn't figure out how to fix. It only affected one course in this graphic though so I ignored it. Additional note: I wanted to color all my courses, but I didn't want a legend for them. So I used the guides(fill = FALSE) function from the reading to remove the legend. I do this for every graphic.

plot2 <- ggplot(trial2, aes(x = reorder(course_name, -grad), y = grad, fill = course_name)) +
  labs(
    title = "Top 10 Graduate Courses",
    subtitle = "By Enrollment, Fall 2019",
    x = "Course Name",
    y = "Enrollment"
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8)) +
  geom_col() +
  guides(fill = FALSE)

# Again this is an almost exact mirror of the previous graph by for graduate students. I ran into the name issue again, but for only two classes and they seem fairly self explanatory so I decided to leave it. Oh, I did use reorder() again.

plot_grid(plot1, plot2, labels = "AUTO")

# Here I've installed and used the "cowplot" package, which I found from someone on StackExchange. It is super useful for combing two ggplot graphs in one page labelled "A" and "B". It doesn't mess up my graph labels and generally lets me create two graphs without facet_wrap(). I was doing two Bar charts here, but I'm keeping this package in mind for when I might want to combine two different graphs in one visual.
```


## Graphic: Most Popular Departments
```{r Graphic 2, Prep}
trial3 <- enrollment %>%
  select(course_department, u_grad) %>%
  arrange(desc(u_grad)) %>%
  na.omit(trial)

# I'm not sure why I decided to do this because I don't think it's required for the problem set, but I wanted to see the most popular departments by enrollment numbers for both undergrads and grads. To do that I followed the same strategy as my original graph prep stages, but with a few new things. For some reason I got a "NA" row when I listed the most popular undergraduate departments, so I added the na.omit() function to clean that up.

trial4 <- enrollment %>%
  select(course_department, grad) %>%
  arrange(desc(grad)) %>%
  na.omit(trial)

# This is an exact mirror of trial_3 so I don't really have much to add here. That being said, one issue I had was that in both trial_3 and this dataframe the list included the separate entries of department. Instead of listing all the enrollees for each department, it was essentially still listing enrollees for each class. I tackle this issue next.

trial3x <- ddply(trial3, "course_department", numcolwise(sum)) %>%
  arrange(desc(u_grad)) %>%
  head(10)

# As mentioned above, I had to collapse my variables so that every u_grad enrollment number was added together for each department. I found out the ddply() function from the plyr package did exactly this. After listing adding all enrollment data together for each department by removing duplicate observations of the departments, I just sorted them in descending order and grabbed the top 10.

trial4x <- ddply(trial4, "course_department", numcolwise(sum)) %>%
  arrange(desc(grad)) %>%
  head(10)

# Another mirror of the previous step but for graduate students. One note for loading plyr package though. If you load plyr after dplyr package it creates issues that prevent the rmarkdown page from working properly. You have to load plyr before dplyr for everything to work properly. Maybe there's a function within dplyr that does what I need, but I only found this function from plyr to get exactly what I wanted.
```

```{r Graphic: Departments}
plot3 <- ggplot(trial3x, aes(x = reorder(course_department, -u_grad), 
                             y = u_grad, 
                             fill = course_department)) +
  labs(
    title = "Top Undergraduate Departments",
    subtitle = "By Enrollment, Fall 2019",
    x = "Department",
    y = "Enrollment"
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8)) +
  geom_col() +
  guides(fill = FALSE)

# Here I'm just doing the exact same graphing as I did for the first graphic.This includes the guides(fill = FALSE) command.

plot4 <- ggplot(trial4x, aes(x = reorder(course_department, -grad), y = grad, fill = course_department)) +
  labs(
    title = "Top Gradudate Departments",
    subtitle = "By Enrollment, Fall 2019",
    x = "Department",
    y = "Enrollment"
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 8)) +
  geom_col() +
  guides(fill = FALSE)

# Another mirror of the previous section. I have even less to really say about it at this point.

plot_grid(plot3, plot4, labels = "AUTO")

# Here I use plot_grid() from the "cowplot" package to create another graphic page with two ggplot graphs on it. This creates two stacked graphics containing two graphs each. It shows the most popular courses in Fall 2019 for undergrads and grad students. And then right below that, it shows the overall most popular departments for undergrads and grad students. I think the two graphics compliment eachother.
```

## Cooperation Note
I worked with Bernadette Stadler and Sophia Freuden on this problem set.
